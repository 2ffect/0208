**Django React.js Application
1. Web Browers와 Web Application Server가 통신하는 방법
 1)ajax
  -  Asynchronous Javascript XML(eXtensible Markup Language)의 약자로 Javascript의 비동기 방식을 이용해 XML을 가져오는 것
최근에는 데이터 포맷에 상관없이 비동기적으로 데이터를 가져오는 기술
** 동기 : 하나의 요청이 발생하면 다른 요청은 전부 대기하고 요청을 처리할 때 까지 기다린 후 다음 요청을 처리하는 방식
   비동기 : 하나의 요청이 발생해서 처리 중이더라도 다른 요청을 동시에 처리할 수 있는 방식
비동기를 화면을 부분적으로 갱신하는 것으로 오해하는 경우가 많음 ( ajax로 이 방법을 많이 사용하기 때문)
 [1] 구현 방법
 - XMLHttpRequest 객체 생성
 - 처리 결과를 받을 이벤트 리스너 등록 (콜백을 등록한다 라고 하기도 함)
 - 서버에게 전송할 데이터(파라미터)가 있으면 데이터를 준비
 - open 메서드를 이용해 연결준비
 - send 메서드를 이용해 요청을 전송
 - 

** Event : 사용자나 운영체제등에 의해서 발생하는 동작 (클릭 등)
Listener : 이벤트를 처리하기 위한 함수나 메서드를 가진 객체 (EventHandler 라고도 함)
Callback : 어떤 이벤트가 발생했을 때 호출되는 함수나 메서드



 2) 전체 데이터 가져오기 구현
  >   urls.py 파일에 하나의 요청을 처리하기 위한 url을 등록


from apiapp import views
urlpatterns = [
    path("admin/", admin.site.urls),
    path("example/", include("apiapp.urls")),
    path("ajax/", views.ajax) # ajax/ 라는 요청이 왔을 때 apiapp.views 파일의 ajax 함수가 처리하도록 설정
]

  >  apiapp의 views.py 파일에 요청을 처리하기 위한 ajax함수를 생성

from django.shortcuts import render
# 요청이 오면 templates 디렉토리의 ajax.html 을 출력
def ajax(request):
    return render(request, "ajax.html")

  >  apiapp 디렉토리에 templates 디렉토리를 생성하고 그 안에 ajax.hteml 파일을 생성

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ajax</title>
</head>
<body>
    <script>
        // ajax 요청 객체 생성
        let request = new XMLHttpRequest();
        // 요청을 준비
        request.open('GET','../example/books/')
        // 요청 - 데이터가 없는 경우는 따움표로 대입
        request.send('')
        // 서버에서 요청이 전송되면 호출 될 콜백 메서드 등록
        request.addEventListener('load', function(e){
            // 데이터를 확인 : 텍스트와 JSON은 responesText
            // XML인 경우는 responseXML
            // JSON 문자열을 직접 출력
            alert(request.responseText);
        })
    </script>
</body>
</html>

데이터를 가져오는 URL : 127.0.0.1/example/books

ajax.html의 URL : 127.0.0.1/ajax


  >  javascript에서 JSON데이터 사용 (파싱)
 [1] 결과 = JSON.parse(JSON 문자열) : 배열이나 객체로 변환해서 리턴
 [2] 결과 = JSON.stringify(자바스크립트 객체) : JSON 문자열로 변환해서 리턴

  > JSON.parse(JSON 문자열) : 배열이나 객체로 변환해서 리턴 하는법

              // 받아 온 문자열을 Javascript 객체로 변환
            let data = JSON.parse(request.responseText)
            
            // 자바스크립트는 for ~ in 으로 배열을 순회하면 인덱스가 리턴된다.
            for (idx in data){
                alert(data[idx].bid + data[idx].title)
            }

   >


3) 데이터 삽입 구현 - POST 방식에 데이터 전송
  -  ajax.html 파일의 스크립트만 수정해서 확인

  <script>

        // ajax 요청 객체 생성
        let request = new XMLHttpRequest();

        // POST 방식에서 전송할 데이터를 생성
        let formdata = new FormData();
        formdata.append('bid',119);
        formdata.append('title','손자병법');
        formdata.append('author','김재희');
        formdata.append('date','2024-01-29')

       // 요청을 준비하고 전송
        request.open("POST", "../example/books");


        // 데이터 변환 (GET 방식에서는 안해도 됨, PUT or POST 방식에서는 필수로 해줘야한다.)
        request.setRequestHeader("Content-type",
            "application/x-www-form-urlcencoded");
        let param = "";
        for(let pair of formdata.entries()){
            param += pari[0] + '=' + pair[1] + '&';
        }

        request.send(param);

        request.addEventListener("load", function(e){
            alert(request.response.Text);
        })
        
    </script>

5) fetch API
  >  fetch api는 프로미스 기반의 api (ajax 는 콜백 방식)
콜백 방식은 별동릐 함수를 만들어 연결하는 반면, 프로미스 기반에서는 .then 또는 .catch를 연달아 작성한다.
도큐먼트 : https://developer.mozilla.org/en-US/dpcs/Web/API/fetch


 [1] ajax.html 파일의 스크립트를 사용해 전체 데이터 가져오기 구현

    <script>
        // 첫번째 then에서는 어떤 데이터인지 알려주면 파싱을 해 다음 then에게 넘겨준다.
        // 다음 then에서 data를 사용하면 된다.
        // 여러개의 문장을 수행할 경우 { } 사용
        // 예외 처리는 catch로 수행하며 chatc의 매개변수는 예외 객체
        fetch('../example/books/')
        .then((response) => response.json())
        .then((data) => console.log(data))

        // 예외 처리
        .catch((error) => console.log(error));
        
    </script>


6) axios 라이브러리
  -  Promise 기반 HTTP 클라이언트 기반의 비동기 데이터 요청을 위한 라이브러리
동일한 코드로 node.js 기반의 서버와 클라이언트에서 동일한 기능을 수행할 수 있다.
도큐먼트 : https://axios-http.com/kr/docs/intro

최근에 많이 사용된다.
  >  스크립트 수정
    <!-- axios 라이브러를 사용하기 위한 링크 설정 -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        axios.get('../example/books/')
        .then((response) =>console.log(data))
        // 예외 처리
        .catch((error) => console.log(error));
        
    </script>

일반적으로 ajax보다는 fetch api가 fetch api 보다는 axios 라이브러리를 사용하는 것이 코드가 간결하다 하지만 axios는 표준 기술이 아니기 때문에 외부의 영향을 받게 된다.


7) Web Socket
  -  ajax나 fetch api는 무상태 방식이며 연결을 유지하지 않는다.
ajax나 fetch api를 이용해선 채팅과 같은 계속하여 데이터를 주고받는 서비스 구현이 어렵다. 채팅을 구현하게 된다면 오버헤드가 너무 크다.

8) Web Push
  -  클라이언트의 요청이 없어도 서버가 클라이언트에게 데이터를 전송하는 것
예전에는 ajax polling을 통해 구현했지만 요즘은 Web Push(Server Side Event)를 통해 구현한다. 부인 봉쇄를 위해서 구현하는 경우가 있다. 모바일의 경우 APNS(Apple Push Notification Service) 나 FCM(Firebase Cloud Messaging)이 UDP로 구현되어 있기 때문에 부인봉쇄에 사용할 수 없다.

** 부인봉쇄(Non-repudiation) : 송신자가 수신자에게 보낸 정보를 자신이 보내지 않았다고 '부인'하는 것을 막아버리는 것

9) CSRF(Cross-Site Request Forgery)
  -  사용자가 의도하지 않은 공격을 시도하는 행위 
토큰을 발급해 토큰이 있는 사용자만 서버에게 요청할 수 있도록 하여 막을 수 있다.
Django의 경우 클라이언트를 외부에서 만들 때 CSRF설정을 필수로 요구한다. (내부는 안해도 된다)

10) SOP(Same Origin Policy - 동일 출처 정책)
  -  자바스크립트는 기본적으로 동일한 도메인 내에서만 요청이 가능하다.
도메인이 다르면 요청을 못한다.
SOP가 적영되지 않는 태그
<img>, <video>, <a>, <audio>, <embed>, <object>

ajax나 fetch api는 SOP가 적용되기 때문에 도메인이 다른 서버에 데이터 요청이 불가능하다.
따라서 서버에 접속할 수 있는 클라이언트의 도메인을 등록해주거나 react와 같은 클라이언트 사이드 애플리케이션 프레임워크에 접속할 수 있는 서버에 등록해주어야 한다.
근본적으로 서버에서 작업을 해야하지만 react의 경우 클라언트에서 설정할 경우 node로 만들어진 서버의 프록시 설정을 이용해 가능하도록 해줘야 한다.

 컴퓨터
          Proxy(프록시) > 외부    : 나가는 것을 막는것
          Firewall(방화벽) < 외부 : 들어오는 것을 막는것


2. ToDoService 구현
1) 구현 
  -  Django Framework를 이용해 BackEnd Application을 구현하고 react.js를 이용해 FrontEnd Application을 구현

  > 구현기능
 [1] ToDo 생성
 [2] ToDo 목록보기
 [3] ToDo 수정
 [4] ToDo 삭제
  -  서버 API 테스트 : postman 이용

2) 데이터베이스에 접속해 이용할 데이터베이스를 결정
  >  mango 데이터베이스 이용

DBeaver 에서 use mango;


3) BackEnd Application 생성
  >  ToDoService 디렉토리를 생성후 아래에 BackEnd 디렉토리를 생성해 가상환경을 만들고 활성화 시킨다. 그리고 패키지를 설치 해준다.
python -m venv myvenv (가상환경 생성 명령어)
myvenv\Scripts\activate (가상환경 접속)
pip install django mysqlclient (패키지 설치)

django-admin startproject todoproject . (프로젝트 생성 명령어)
** 주의 :  마지막에 . 을 추가하지 않으면 todoproject 디렉토리가 생성되고 그 안에 프로젝트가 생성되어 디렉토리 안에서 작업을 수행하여야 한다.  . 을 꼭 추가할 것
python manage.py startapp todoapplication ( 애플리케이션 생성 명령어)


4) 기본 설정 수정 - 프로젝트 디렉토리의 settings.py 파일 수정
배포를 하기 위해선 기본적으로 
ALLOWED_HOSTS = ['*']  < [] 안에 '*'를 넣어 줘야한다.

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "todoapplication",
]
내가 사용할 어플리케이션을 추가해 준 뒤 데이터베이스 기본 정보를 설정한다.

데이터베이스 정보까지 설정을 했다면 시간대역도 설정을 해준다.
여기까지가 Python Django project의 기본설정이다.

  >  서버를 구동해 설정이 설정이 잘 적용 되었는지 확인
python manage.py runserver 0.0.0.0:80

5) 모델 생성
  >  모델 설계
 [1] ID : 키본키이고 자동 입력
 [2] userid : 유저 아이디로 문자열, 15글자
 [3] title : 해야 할 일로 문자열이고 100글자
 [4] done : 수행여부를 나타내는 것으로 불린이고 기본값은 False
 [5] regdate : 생성 날짜로 기본값은 오늘 날짜를 설정
 [6] moddate : 수정 날짜(ToDo를 완료한 날짜)로 선택적으로 입력

  >  어플리케이션의 models.py에 모델을 생성

from django.db import models

# Create your models here.

class ToDo(models.Model):
    id = models.AutoField(primary_key = True)
    userid = models.CharField(max_length = 15)
    title = models.CharField(max_length = 100)
    done = models.BooleanField(default=False)
    regdate = models.DateTimeField(auto_now_add = True)
    moddate = models.DateTimeField(null=True)

  >  설정 내용을 데이터베이스에 반영
python manage.py makemigrations
python manage.py migrate

  >  데이터베이스에 접속해 확인
명령어는 아래와 같다.
desc 앱이름_모델이름;
나는 아래다.
desc todoapplication_todo;

6) BackEnd CRUD 처리 : 하나의 클래스로 모든 요청을 처리
  >  하나의 클래스로 하나의 모델에 대한 모든 처리를 수행할 때 주의할 부분은 GET의 구현이다.
GET의 구현은 일반적으로 2가지 정도로 나뉜다. 전체 데이터 보기와 상세보기 이다.
2가지를 모두 구현해야 할 경우 하나의 클래스 함수 내에서 분기를 하거나 2개 이상의 클래스로 나누어 처리해야 한다.
지금 실습에서는 전체보기만 구현할 예정으로 분기는 생략한다.


7) 삽입 요청 처리
  >  애플리케이션의 views.py 파일에 요청을 처리하는 함수를 작성한다.

# 클래스형 view를만들기 위해서 import
from django.views import view
# csrf 설정을 위한 import
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
# 데이터 모델을 가져오기 위한 import
from .models import Todo
# 날짜와 시간을 사용하기 위한 import
from datetime import datetime
# JSON으로 응답하기 위한 import
from django.http import JsonResponse
# 클라이언트의 정보를 JSON 문자열로 변환하기 위한 import
import json # python 기본 라이브러리

# 모델 클래스의 인스턴스를 딕셔너리로 변환해주는 함수 작성
# JsonResponse로 JSON 데이터를 출력 시 JSON 문자로 빠르게 변환 시키려면 JSON 문자열과 표현 방법이 같은 dict만 가능하다.
# python application 개발자가 되기 위해서는 함수를 만들 때 매개변수에 자료형을 기재하고
# return type을 기재하는 형태로 만들어주는 것이 좋다.
def todoDictionary(todo:Todo) -> dict:
    result = {
        "id" : todo.id,
        "userid" : todo.user.id,
        "title" : todo.title,
        "done" : todo.done,
        "regdate" : todo.regdate,
        "moddate" : todo.moddate,
    }

# csrf 설정으로 클라이언트 애플리케이션을 별도로 구현하는 경우 필수
@method_decorator(csrf_exempt, name = 'dispatch') # 이름은 보통 dispatch 를 사용한다.
class TodoView(View):
    # POST를 처리
    def post(self,requset):
        # 클라이언트 데이터 가져오기
        requset = json.loads(requset.data)

        # 클라이언트에서 입력해주는 데이터만 읽어오면 된다.
        # userid 와 title의 매개변수 값을 읽어서 저장
        userid = requset["userid"]
        title = requset["title"]

        #모델 인스턴스 생성
        todo = Todo()
        todo.userid = userid
        todo.title = title
        
        todo.save() # 저장

        # userid 와 일치하는 데이터만 추출
        todos = Todo.object.filter(userid = userid)

        # 결과 리턴
        # 삽입은 특별한 경우가 아니라면 데이터의 처음과 끝에 추가되기 때문에 보통 전체 데이터를 return 해도 상관없다.
        # 수정과 삭제의 경우는 테이터의 처음과 끝이 아닐수 있기 때문에 보통 수정되거나 삭제된 부분을 return 해준다.
        return JsonResponse({"list" : list(todos.valuse)})

  >  urls.py 파일에 url 요청 처리 클래스를 연결

from todoapplication import views

urlpatterns = [
    path("admin/", admin.site.urls),
    path("todo/", views.TodoView.as_view()),
]

  >  서버 실행
rest_framework를 사용하지 않았기 때문에 GET방식은 테스트가 가능하지만 나머지 방식은 테스트 불가
나머지 방식은 웹테스트 도구를 설치하여 테스트를 진행한다.
  >  postman api를 이용해 테스트 진행


8) 전체 데이터 가져오기 처리 (GET)
  >  애플리케이션 views.py에 GET을 처리할 함수를 추가

# GET을 처리
    def get(self, requset):
        # GET 방식에서 userid 라는 파라미터를 읽기
        userid = requset.GET["userid"]
        todos = Todo.objects.filter(userid = userid)
        return JsonResponse({"list" : list(todos.values())})

  > GET의 경우 브라우저에 직접 URL을 입력해도 테스트 가능하다.
127.0.0.1/todo/?userid=아이디 로 확인

  >  목록을 리턴해야 하는 경우 리스트가 있으면 해당 리스트를 리턴하고 데이터가 없는 경우 빈 리스트를 리턴하도록 해야한다. null이 리턴되서는 안된다.
목록이 아닌 하나의 데이터를 리턴하게 될 때는 데이터가 없을 경우 None(null)을 리턴하도록 한다.
목록을 리턴하게 되면 클라이언트에서 반복문을 수행하기 때문에 null 값이 들어갈 경우 에러가 발생하기 때문이다.
    
9) 데이터 수정 처리 (PUT)
  >  데이터 수정을 할때 넘겨줄 데이터 : userid, id, done 을 넘겨준다.
  >  애플리케이션 views.py에 PUT을 처리할 함수를 추가

def put(self,requset):
        # 클라이언트 데이터 가져오기
        # requset = json.loads(requset.data) # 에러
        requset = json.loads(requset.body)

        # 클라이언트에서 입력해주는 데이터만 읽어오면 된다.
        # userid 와 id그리고 done 매개변수 값을 읽어서 저장
        userid = requset["userid"]
        id = requset["id"]
        # done = requset["done"]

        # 수정할 데이터를 찾아온다
        todo = Todo.objects.get(id = id)
        # 수정할 내용을 대입
        todo.userid = userid
        # todo.id = id
        # todo.done = done
        # save는 기본키의 값이 있으면 수정이고 없으면 삽입이다.
        todo.save() # 저장

        # userid 와 일치하는 데이터만 추출
        todos = Todo.objects.filter(userid = userid)        

        return JsonResponse({"list" : list(todos.values())})

10) 데이터 삭제 처리 (DELETE)
  >  데이터 삭제 할때 넘겨줄 데이터 : userid
  >  애플리케이션 views.py에 DELETE를 처리할 함수를 추가

    # DELETE를 처리
    def delete(self,requset):
        # 클라이언트 데이터 가져오기
        # requset = json.loads(requset.data) # 에러
        requset = json.loads(requset.body)

        # 클라이언트에서 입력해주는 데이터만 읽어오면 된다.
        # userid 와 id그리고 done 매개변수 값을 읽어서 저장
        userid = requset["userid"]
        id = requset["id"]
        # done = requset["done"]

        # 삭제할 데이터를 찾아온다
        todo = Todo.objects.get(id = id)
        # user를 확인해서 삭제
        if userid == todo.userid:
            todo.delete()

        # userid 와 일치하는 데이터만 추출
        todos = Todo.objects.filter(userid = userid)        

        return JsonResponse({"list" : list(todos.values())})

  >  POSTMAN에서 테스트

GET : 조회에 이용
데이터를 URL 뒤에 삽입해서 전송 : URL?이름=값&이름=값... 방식
값의 길이에 제한이 있다.
데이터가 외부로 노출되기 때문에 보안성이 떨어진다.
자동 재전송이 가능하다
인코딩을 Web Server가 수행한다.
파라미터를 전송할 때 인코딩을해서 전송해야 한다.
서버 랜더링을 하는 경우 대부분 forwarding을 수행

POST, PUT, DELETE : 삽입(등록), 갱신(수정), 삭제에 이용
데이터를 헤더에 포함시켜 전송
값의 길이에 제한이 없다.
데이터가 외부로 노출되지 않는다.
인코딩을 Application Server가 수행한다.

서버 랜더링을 하는 경우 대부분 redirect를 수행

3. BackEnd 애플리케이션 코드를 github에 업로드

 [1] 프로젝트에 .gitignore 파일을 생성하고 가상환경 디렉토리를 기재

 [2] 패키지 목록을 텍스트 파일로 내보내기
pip freeze > requirements.txt

 [3] 레포지토리를 생성하고 url 복사
https://github.com/2ffect/todobackend.git

 [4] 프로젝트 디렉토리 프롬프트에서 수행
git init (처음 한번만)
git add . (수정을 할 때 마다)
git commit -m "메세지" (수정을 할 때마다)
  -  여기까지 수행하면 변경 사항을 로컬 git에 반영한 것

 [5] 로컬 git과 github Repository 연결
git remote add 이름 Repositoryurl
(로컬 git과 github Repository 연결) 처음 만들때는 이름 origin으로
git remote add origin https://github.com/2ffect/todobackend.git

연결확인 : git remote -v
연결해제 : git remote remove 이름
  -  연결 작업도 일반적으로 처음에 한 번 수행

 [6] Github Repository 에 push(업로드) 하기
현재 브랜치 확인 : git branch

git push Repository연결이름 브랜치 이름
git push origin main


4. 다른 컴퓨터에서 Github를 통해 프로젝트를 가져온 후 다시 업로드 하기
 [1] 프로젝트 가져오기 
git clone Repositoryurl
 
 [2] 가상환경 생성 및 활성화
python -m venv myvenv
myvenv\scripts\activate
 
 [3] 패키지 설치
pip install -r requirements.txt
(requirements.txt에 적힌 모든 패키지를 한번에 설치한다.)
  -  이제는 프로젝트와 동일한 환경이 구성되었다.
작업을 수행 후 commit 하고 push 했으면 다른 쪽에서 git pull Repository이름 브랜치 이름을 수행해 변경 내역을 반영한 후 작업을 수행해야 한다.




GET : 조회에 이용
데이터를 URL 뒤에 삽입해서 전송 : URL?이름=값&이름=값... 방식
값의 길이에 제한이 있다.
데이터가 외부로 노출되기 때문에 보안성이 떨어진다.
자동 재전송이 가능하다
인코딩을 Web Server가 수행한다.
파라미터를 전송할 때 인코딩을해서 전송해야 한다.
서버 랜더링을 하는 경우 대부분 forwarding을 수행


POST, PUT, DELETE : 삽입(등록),  갱신(수정), 삭제에 이용
데이터를 헤더에 포함시켜 전송
값의 길이에 제한이 없다.
데이터가 외부로 노출되지 않는다.
인코딩을 Application Server가 수행한다.

서버 랜더링을 하는 경우 대부분 redirect를 수행